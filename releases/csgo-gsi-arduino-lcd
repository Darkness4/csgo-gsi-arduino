#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CSGO's informations displayed on an Arduino featuring a bomb timer.

@auteur: tsuriga, Darkness4
"""

from http.server import BaseHTTPRequestHandler, HTTPServer
from sys import argv
from time import time, sleep, asctime
from json import loads, dumps
from serial import Serial
from serial.tools import list_ports
from qtpy.QtWidgets import (QPushButton, QApplication, QComboBox,
                            QVBoxLayout, QHBoxLayout, QWidget)
from qtpy.QtCore import Slot, QThread, Qt
from threading import Thread

__title__ = "csgo-gsi-arduino-lcd"
__version__ = "1.3.0"
__project_url__ = 'https://github.com/Darkness4/csgo-gsi-arduino-lcd'
__credits__ = ["tsuriga", "Darkness4"]

print(__title__+" "+__version__)


def get_round_phase(payload):
    """Get round phase."""
    if 'round' in payload and 'phase' in payload['round']:
        return payload['round']['phase']


def get_state(payload):
    """Get player status."""
    if 'player' in payload and 'state' in payload['player']:
        return {'health': payload['player']['state']['health'],
                'armor': payload['player']['state']['armor'],
                'round_kills': payload['player']['state']['round_kills'],
                'round_killhs': payload['player']['state']['round_killhs'],
                'money': payload['player']['state']['money']}


def get_bomb(payload):
    """Get bomb status."""
    if 'round' in payload and 'bomb' in payload['round']:
        return payload['round']['bomb']


def progress(i):
    """Progress bar, for arduino 5px large."""
    switcher = {i <= 0: b"\x07",
                i == 1: b"\x02",
                i == 2: b"\x03",
                i == 3: b"\x04",
                i == 4: b"\x05",
                i >= 5: b"\x06"}
    return switcher[True]


def bombtimer(ser_arduino):
    """40s bomb timer on arduino."""
    offset = time()
    actualtime = 40 - time() + offset
    while actualtime > 0:
        oldtime = int(actualtime)
        sleep(0.1)
        actualtime = 40 - time() + offset
        if oldtime != int(actualtime):  # Actualization
            ser_arduino.write(b'BOMB PLANTED')
            # Wait for second line
            sleep(0.1)
            ser_arduino.write(progress(int(actualtime)))  # 5s max
            ser_arduino.write(progress(int(actualtime - 5)))  # 10s max
            ser_arduino.write(progress(int(actualtime - 10)))  # 15s max
            ser_arduino.write(progress(int(actualtime - 15)))  # 20s max
            ser_arduino.write(progress(int(actualtime - 20)))  # 25s max
            ser_arduino.write(progress(int(actualtime - 25)))
            ser_arduino.write(progress(int(actualtime - 30)))
            ser_arduino.write(progress(int(actualtime - 35)))
            ser_arduino.write(bytes(str(int(actualtime)).encode()))
    return


def serial_ports():
    """List serial port names."""
    return [port.device for port in list_ports.comports()]


class MyServer(HTTPServer):
    """Server storing CSGO's information."""

    def init_state(self, ser_arduino):
        """You can store states over multiple requests in the server."""
        self.round_phase = None
        self.bomb = None
        self.state = None
        self.waiting = False
        self.payloadviewer = None
        self.ser_arduino = ser_arduino
        self.messenger = Messenger(ser_arduino)
        self.messenger.start()
        print(asctime(), '-', "Messenger is online.")


class MyRequestHandler(BaseHTTPRequestHandler):
    """CSGO's requests handler."""

    def do_POST(self):
        """Receive CSGO's informations."""
        length = int(self.headers['Content-Length'])
        body = self.rfile.read(length).decode('utf-8')

        self.parse_payload(loads(body))

        self.send_header('Content-type', 'text/html')
        self.send_response(200)
        self.end_headers()

    # Parsing and actions
    def parse_payload(self, payload):
        """Search payload and execute arduino's codes."""
        round_phase = get_round_phase(payload)

        if round_phase is not None:
            self.server.waiting = False
            bomb = get_bomb(payload)
            state = get_state(payload)
            if bomb != self.server.bomb:
                if bomb == 'planted':
                    self.server.bomb = bomb
                    self.server.messenger.changestatus("Bomb")
                elif bomb == 'defused':
                    self.server.bomb = bomb
                    self.server.messenger.changestatus("Defused")
                elif bomb == 'exploded':
                    self.server.bomb = bomb
                    self.server.messenger.changestatus("Exploded")
            elif state != self.server.state:  # if the state has changed
                self.server.messenger.changestatus("!Freezetime")
                self.server.state = state  # Gather player's state
                # Progress bar HP AM
                self.server.messenger.health = int(state['health'])
                self.server.messenger.armor = int(state['armor'])
                self.server.messenger.money = int(state['money'])
                self.server.messenger.setkills(state['round_kills'],
                                               state['round_killhs'])
                if round_phase != 'freezetime':
                    self.server.messenger.changestatus("!Freezetime")
                else:  # Not kill streak
                    self.server.messenger.changestatus("Freezetime")
        elif not self.server.waiting:
            self.server.waiting = True  # isWaiting
            self.server.messenger.changestatus("None")

        #  Start the payload viewer
        if (self.server.payloadviewer is not None
           and payload != self.server.payloadviewer.payload):
            self.server.payloadviewer.setpayload(payload)
            self.server.payloadviewer.refresh()

    def log_message(self, format, *args):
        """Prevents requests from printing into the console."""
        return


class ServerThread(QThread):
    """Server's thread."""

    ser_arduino = None
    server = None

    def __init__(self, com_str):
        """Start thread and save the COM port."""
        QThread.__init__(self)
        self.com_str = com_str

    def run(self):
        """Start the server."""
        self.ser_arduino = Serial(self.com_str, 9600)
        sleep(2)  # Wait for arduino
        print(asctime(), '-', "Arduino detected")
        # Launch server
        self.server = MyServer(('localhost', 3000), MyRequestHandler)
        self.server.init_state(self.ser_arduino)  # Init var
        print(asctime(), '-', 'CS:GO GSI Quick Start server starting')
        self.server.serve_forever()  # Run
        self.server.server_close()  # Close server
        print(asctime(), '-', 'CS:GO GSI Quick Start server stopped')
        self.ser_arduino.close()  # Close COM port
        print(asctime(), '-', 'Serial stopped')


class Csgogsi(QWidget):
    """App UI."""

    def __init__(self):
        """Init UI."""
        super(Csgogsi, self).__init__()
        # Widgets
        self.serverthread = None
        self.connectbtn = QPushButton('Connect')
        self.connectbtn.clicked.connect(self.connect)

        self.comcb = QComboBox()
        self.comcb.addItems(serial_ports())
        if serial_ports() == []:
            self.connectbtn.setDisabled(True)
        else:
            self.connectbtn.setDisabled(False)

        self.refreshbtn = QPushButton('Refresh')
        self.refreshbtn.resize(self.refreshbtn.sizeHint())
        self.refreshbtn.clicked.connect(self.refresh)

        self.payloadviewerbtn = QPushButton('View payload')
        self.payloadviewerbtn.setDisabled(True)

        # Container
        vbox = QVBoxLayout()
        hbox = QHBoxLayout()
        vbox.addStretch(1)
        hbox.addWidget(self.comcb)
        hbox.addWidget(self.refreshbtn)
        vbox.addLayout(hbox)
        vbox.addWidget(self.payloadviewerbtn)
        vbox.addWidget(self.connectbtn)
        self.setLayout(vbox)
        # Window
        self.setWindowTitle('CSGO GSI on LCD')
        self.setWindowFlags(Qt.WindowCloseButtonHint)

        self.show()
        self.setFixedSize(self.size())

    @Slot()
    def refresh(self):
        """Refresh COM ports."""
        self.comcb.clear()
        self.comcb.addItems(serial_ports())
        if serial_ports() == []:
            self.connectbtn.setDisabled(True)
        else:
            self.connectbtn.setDisabled(False)

    @Slot()
    def connect(self):
        """Connect to the server."""
        # Disable buttons
        self.comcb.setDisabled(True)
        self.connectbtn.setDisabled(True)
        self.refreshbtn.setDisabled(True)
        # Server start
        if self.serverthread is None:
            self.serverthread = ServerThread(str(self.comcb.currentText()))
        self.serverthread.start()
        # Change connect button's function to "stop"
        self.connectbtn.clicked.disconnect()
        self.connectbtn.clicked.connect(self.stop)
        self.connectbtn.setDisabled(False)
        self.connectbtn.setText('Stop')
        # Enable payloadviewer
        self.payloadviewerbtn.clicked.connect(self.startpayloadviewer)
        self.payloadviewerbtn.setDisabled(False)

    @Slot()
    def stop(self):
        """Stop the server."""
        # Disable buttons
        self.payloadviewerbtn.setDisabled(True)
        # Kill the messenger and server
        self.serverthread.server.messenger.shutdown()
        if (self.serverthread.server.payloadviewer is not None
           and self.serverthread.server.payloadviewer.is_alive()):
            self.serverthread.server.payloadviewer.shutdown()
            self.serverthread.server.payloadviewer = None
        self.serverthread.server.shutdown()
        self.serverthread = None
        # Change button function
        self.connectbtn.clicked.disconnect()
        self.connectbtn.clicked.connect(self.connect)
        self.connectbtn.setText('Connect')
        self.payloadviewerbtn.clicked.disconnect()
        self.payloadviewerbtn.clicked.connect(self.startpayloadviewer)
        self.payloadviewerbtn.setText('View payload')
        # Enable buttons
        self.comcb.setDisabled(False)
        self.connectbtn.setDisabled(False)
        self.refreshbtn.setDisabled(False)

    @Slot()
    def startpayloadviewer(self):
        """Stop the server."""
        # Start payload vierwer
        self.serverthread.server.payloadviewer = PayloadViewerThread()
        self.serverthread.server.payloadviewer.start()

        # Change button function
        self.payloadviewerbtn.clicked.disconnect()
        self.payloadviewerbtn.clicked.connect(self.stoppayloadviewer)
        self.payloadviewerbtn.setText('Hide payload')

    @Slot()
    def stoppayloadviewer(self):
        """Stop the server."""
        # Stop payload viewer
        self.serverthread.server.payloadviewer.shutdown()
        self.serverthread.server.payloadviewer = None

        # Change button function
        self.payloadviewerbtn.clicked.disconnect()
        self.payloadviewerbtn.clicked.connect(self.startpayloadviewer)
        self.payloadviewerbtn.setText('View payload')

    def closeEvent(self, *args, **kwargs):
        """Close everything before closing app."""
        super(Csgogsi, self).closeEvent(*args, **kwargs)
        if (self.serverthread is not None
           and self.serverthread.server.messenger.is_alive()):
            self.serverthread.server.messenger.shutdown()
        if self.serverthread is not None and self.serverthread.isRunning():
            self.serverthread.server.shutdown()


class Messenger(Thread):
    """Give order to the arduino."""

    __start__ = True  # Order to start/stop
    __refresh__ = False  # Order to refresh informations
    health = None
    armor = None
    money = None
    kills = None  # tuple (total kills - hs, hs)
    status = "None"

    def __init__(self, ser_arduino):
        """Init save."""
        super(Messenger, self).__init__()
        self.ser_arduino = ser_arduino

    def run(self):
        """Thread start."""
        while self.__start__:
            if self.__refresh__:
                self.__refresh__ = False  # Has refreshed
                if self.status in ("Bomb", "Defused", "Exploded"):  # Bomb
                    self.bombtimer()

                elif self.status == "None":
                    self.idle()

                else:  # Default status
                    self.playerstats()
        print(asctime(), "-", "Messenger is dead.")

    def bombtimer(self):
        """40s bomb timer on arduino."""
        offset = time()
        actualtime = 40 - time() + offset
        while actualtime > 0 and self.status == "Bomb":
            oldtime = int(actualtime)
            sleep(0.1)
            actualtime = 40 - time() + offset
            if oldtime != int(actualtime):  # Actualization only integer change
                self.ser_arduino.write(b'BOMB PLANTED')
                # Wait for second line
                sleep(0.1)
                self.ser_arduino.write(progress(int(actualtime)))  # 5s
                self.ser_arduino.write(progress(int(actualtime - 5)))  # 10s
                self.ser_arduino.write(progress(int(actualtime - 10)))  # 15s
                self.ser_arduino.write(progress(int(actualtime - 15)))  # 20s
                self.ser_arduino.write(progress(int(actualtime - 20)))  # 25s
                self.ser_arduino.write(progress(int(actualtime - 25)))
                self.ser_arduino.write(progress(int(actualtime - 30)))
                self.ser_arduino.write(progress(int(actualtime - 35)))
                self.ser_arduino.write(bytes(str(int(actualtime)).encode()))
                sleep(0.1)
        if self.status == "Defused":
            self.ser_arduino.write(b'BOMB DEFUSED')
            # Wait for second line
            sleep(0.1)
            self.ser_arduino.write(b' ')
            sleep(0.1)
        elif self.status == "Exploded":
            self.ser_arduino.write(b'BOMB EXPLODED')
            # Wait for second line
            sleep(0.1)
            self.ser_arduino.write(b' ')
            sleep(0.1)

    def playerstats(self):
        """Player's stats writer."""
        self.ser_arduino.write(b'H: ')  # Writing health and armor in Serial
        self.ser_arduino.write(progress(int(self.health / 5)))
        self.ser_arduino.write(progress(int((self.health - 25) / 5)))
        self.ser_arduino.write(progress(int((self.health - 50) / 5)))
        self.ser_arduino.write(progress(int((self.health - 75) / 5)))
        self.ser_arduino.write(b' A: ')
        self.ser_arduino.write(progress(int(self.armor / 5)))
        self.ser_arduino.write(progress(int((self.armor - 25) / 5)))
        self.ser_arduino.write(progress(int((self.armor - 50) / 5)))
        self.ser_arduino.write(progress(int((self.armor - 75) / 5)))

        # Wait for second line
        sleep(0.1)

        # Kill or Money
        if self.status == "!Freezetime":
            # HS and Kill counter
            self.ser_arduino.write(b'K: ')
            for _ in range(0, self.kills[0]):  # counting
                self.ser_arduino.write(b'\x00')  # Byte 0 char : kill no HS
            for _ in range(0, self.kills[1]):  # counting
                self.ser_arduino.write(b'\x01')  # Byte 1 char : HS

        elif self.status == "Freezetime":  # Not kill streak
            self.ser_arduino.write(
                bytes('M: {}'.format(self.money).encode()))
        sleep(0.1)

    def idle(self):
        """Print text while idle."""
        self.ser_arduino.write(b'Waiting for')
        sleep(0.1)
        self.ser_arduino.write(b'matches')

    def changestatus(self, status):
        """
        Change Messenger behavior.

        Available status :
        'None'
        'Bomb'
        '!Freezetime'
        'Freezetime'
        'Defused'
        'Exploded'
        """
        self.status = status
        self.__refresh__ = True  # Informations need to be refreshed

    def setkills(self, kills, heads):
        """Set kills."""
        self.kills = (int(kills)-int(heads), int(heads))

    def shutdown(self):
        """Stop the messenger."""
        self.__start__ = False


class PayloadViewerThread(Thread):
    """CSGO's requests handler."""

    __start__ = True  # Order to start/stop
    __refresh__ = False
    payload = None

    def __init__(self):
        """Start thread."""
        super(PayloadViewerThread, self).__init__()

    def run(self):
        """Print payload."""
        while self.__start__:
            if self.__refresh__:
                print(dumps(self.payload, indent=4))
                self.__refresh__ = False

    def shutdown(self):
        """Shutdown thread."""
        self.__start__ = False

    def setpayload(self, payload):
        """Update payload."""
        self.payload = payload

    def refresh(self):
        """Refresh."""
        self.__refresh__ = True


if __name__ == '__main__':
    APP = None
    APP = QApplication(argv)
    EX = Csgogsi()
    exit(APP.exec_())
